<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Práctica de Trigonometría</title>

    <!-- KaTeX CSS -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    />

    <!-- KaTeX JS Core -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    ></script>

    <!-- KaTeX auto-render extension -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    ></script>

    <style>
      /* --- Global Styles & Reset --- */
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        background-color: #f8f9fa;
        color: #343a40;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        padding: 20px;
      }

      h1,
      h2 {
        text-align: center;
        margin-bottom: 25px;
        color: #0056b3; /* Deep blue */
      }

      h1 {
        font-size: 2.5rem;
      }

      h2 {
        font-size: 1.8rem;
        margin-top: 30px;
      }

      /* --- Layout Containers --- */
      .container {
        max-width: 900px;
        margin: 20px auto;
        background-color: #ffffff;
        padding: 30px 40px;
        border-radius: 12px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        flex-grow: 1;
      }

      .main-content {
        display: flex;
        flex-direction: column;
        gap: 30px;
      }

      /* --- Topic Selection --- */
      .topic-selector {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        margin-bottom: 30px;
        padding-bottom: 20px;
        border-bottom: 1px solid #dee2e6;
      }

      .topic-button {
        padding: 12px 25px;
        font-size: 1rem;
        border: 1px solid #007bff;
        border-radius: 25px; /* Pill shape */
        background-color: #ffffff;
        color: #007bff;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 500;
      }

      .topic-button:hover {
        background-color: #e7f3ff; /* Light blue on hover */
        transform: translateY(-2px);
      }

      .topic-button.active {
        background-color: #007bff;
        color: #ffffff;
        border-color: #0056b3;
        box-shadow: 0 2px 5px rgba(0, 123, 255, 0.3);
      }

      /* --- Problem Area --- */
      .problem-area {
        background-color: #f8f9fa; /* Light grey background */
        padding: 25px;
        border-radius: 8px;
        border: 1px solid #e9ecef;
        min-height: 100px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #problem-display {
        font-size: 1.2rem;
        line-height: 1.8;
        text-align: center;
        color: #212529; /* Darker text */
      }

      /* Make KaTeX display block elements vertically */
      #problem-display .katex-display {
        display: block;
        margin: 1em 0;
      }
      #feedback .katex-display {
        display: block;
        margin: 0.8em 0;
      }
      #feedback .explanation-step {
        margin-bottom: 0.5em;
      }

      /* --- Answer & Procedure --- */
      .answer-section {
        display: flex;
        flex-direction: column;
        gap: 20px;
        align-items: center;
      }

      .input-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      #answer-input {
        padding: 12px 15px;
        font-size: 1.1rem;
        border: 1px solid #ced4da;
        border-radius: 6px;
        min-width: 150px;
        transition: border-color 0.3s ease;
      }

      #answer-input:focus {
        border-color: #80bdff;
        outline: 0;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
      }

      #procedure-area {
        width: 100%;
        max-width: 600px;
        height: 100px;
        padding: 10px;
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        font-size: 0.95rem;
        border: 1px solid #ced4da;
        border-radius: 6px;
        resize: vertical; /* Allow vertical resize */
      }

      label[for="procedure-area"] {
        font-weight: 500;
        color: #495057;
        margin-bottom: -10px; /* Adjust spacing */
      }

      /* --- Control Buttons --- */
      .controls {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 15px;
        margin-top: 15px;
      }

      .control-button {
        padding: 12px 28px;
        font-size: 1rem;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.2s ease;
        font-weight: 500;
      }

      #check-button {
        background-color: #28a745; /* Green */
        color: white;
      }
      #check-button:hover:not(:disabled) {
        background-color: #218838;
        transform: translateY(-1px);
      }
      #check-button:disabled {
        background-color: #94d3a2;
        cursor: not-allowed;
      }

      #new-problem-button {
        background-color: #007bff; /* Blue */
        color: white;
      }
      #new-problem-button:hover:not(:disabled) {
        background-color: #0056b3;
        transform: translateY(-1px);
      }
      #new-problem-button:disabled {
        background-color: #7abaff;
        cursor: not-allowed;
      }

      #prev-problem-button {
        background-color: #6c757d; /* Grey */
        color: white;
      }
      #prev-problem-button:hover:not(:disabled) {
        background-color: #5a6268;
        transform: translateY(-1px);
      }
      #prev-problem-button:disabled {
        background-color: #adb5bd;
        cursor: not-allowed;
      }

      /* --- Feedback Area --- */
      #feedback {
        margin-top: 25px;
        padding: 15px 20px;
        border-radius: 8px;
        font-size: 1.1rem;
        text-align: center;
        line-height: 1.7;
        min-height: 50px;
        border: 1px solid transparent;
      }

      #feedback.correct {
        background-color: #d4edda; /* Light green */
        border-color: #c3e6cb;
        color: #155724; /* Dark green */
      }

      #feedback.incorrect {
        background-color: #f8d7da; /* Light red */
        border-color: #f5c6cb;
        color: #721c24; /* Dark red */
        text-align: left; /* Align explanation left */
      }
      #feedback strong {
        font-weight: 600;
      }
      #feedback p {
        margin-bottom: 10px;
      }
      #feedback p:last-child {
        margin-bottom: 0;
      }

      /* --- Footer --- */
      footer {
        text-align: center;
        margin-top: 40px;
        padding-top: 20px;
        border-top: 1px solid #dee2e6;
        color: #6c757d; /* Grey */
        font-size: 0.9rem;
      }

      /* --- KaTeX Specific Adjustments --- */
      .katex {
        font-size: 1.1em; /* Slightly larger math font */
      }

      /* --- Responsiveness --- */
      @media (max-width: 768px) {
        body {
          padding: 15px;
        }
        h1 {
          font-size: 2rem;
        }
        h2 {
          font-size: 1.5rem;
        }
        .container {
          padding: 20px;
        }
        .topic-selector {
          gap: 10px;
        }
        .topic-button {
          padding: 10px 20px;
          font-size: 0.9rem;
        }
        .problem-area {
          padding: 20px;
        }
        #problem-display {
          font-size: 1.1rem;
        }
        .controls {
          flex-direction: column;
          align-items: center;
        }
        .control-button {
          width: 80%;
          max-width: 300px;
        }
        #answer-input {
          min-width: 120px;
          font-size: 1rem;
        }
      }
      @media (max-width: 480px) {
        body {
          padding: 10px;
        }
        h1 {
          font-size: 1.8rem;
        }
        .container {
          padding: 15px;
        }
        .topic-button {
          padding: 8px 15px;
          font-size: 0.85rem;
          border-radius: 20px;
        }
        .input-group {
          flex-direction: column;
          align-items: stretch;
          width: 100%;
        }
        #answer-input {
          width: 100%;
          text-align: center;
        }
        label[for="procedure-area"] {
          text-align: center;
          width: 100%;
        }
        #procedure-area {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <h1>Práctica de Trigonometría</h1>

    <div class="container">
      <div class="main-content">
        <h2>Selecciona un Tema</h2>
        <div class="topic-selector" id="topic-selector">
          <!-- Corrected Topic Name -->
          <button class="topic-button" data-topic="fundamental">
            Funciones Fundamentales
          </button>
          <button class="topic-button" data-topic="reciprocal">
            Funciones Recíprocas
          </button>
          <button class="topic-button" data-topic="complementary">
            Ángulos Complementarios
          </button>
          <button class="topic-button" data-topic="sine">Ley de Senos</button>
          <button class="topic-button" data-topic="cosine">
            Ley de Cosenos
          </button>
        </div>

        <h2>Problema</h2>
        <div class="problem-area">
          <div id="problem-display">Selecciona un tema para empezar.</div>
        </div>

        <div class="answer-section">
          <div class="input-group">
            <label for="answer-input">Tu Respuesta:</label>
            <input
              type="text"
              id="answer-input"
              placeholder="Escribe tu respuesta aquí"
            />
          </div>

          <label for="procedure-area">Procedimiento (Opcional):</label>
          <textarea
            id="procedure-area"
            placeholder="Puedes escribir tus notas o pasos aquí..."
          ></textarea>
        </div>

        <div class="controls">
          <button id="check-button" class="control-button" disabled>
            Revisar Respuesta
          </button>
          <button id="new-problem-button" class="control-button" disabled>
            Nuevo Problema
          </button>
          <button id="prev-problem-button" class="control-button" disabled>
            Problema Anterior
          </button>
        </div>

        <div id="feedback"></div>
      </div>
    </div>

    <footer>Hecho por Luis Humberto Montoya Herrera</footer>

    <script>
      // --- DOM Elements ---
      const topicSelector = document.getElementById("topic-selector");
      const problemDisplay = document.getElementById("problem-display");
      const answerInput = document.getElementById("answer-input");
      const procedureArea = document.getElementById("procedure-area");
      const checkButton = document.getElementById("check-button");
      const newProblemButton = document.getElementById("new-problem-button");
      const prevProblemButton = document.getElementById("prev-problem-button");
      const feedbackDiv = document.getElementById("feedback");
      const topicButtons = document.querySelectorAll(".topic-button");

      // --- State Variables ---
      let currentProblem = null;
      let previousProblem = null;
      let previousUserAnswer = "";
      let previousProcedure = ""; // Store previous procedure too
      let selectedTopic = null;
      const TOLERANCE = 0.015; // Tolerance for floating point comparisons (adjust as needed)
      const ANGLE_TOLERANCE = 0.1; // Tolerance for angle comparisons in degrees
      const ANGLE_MINUTE_TOLERANCE_DEG = 0.5 / 60; // Tolerance for angle comparison in deg/min (e.g., 0.5 minutes)

      // --- Utility Functions ---
      function degToRad(degrees) {
        return degrees * (Math.PI / 180);
      }

      function radToDeg(radians) {
        return radians * (180 / Math.PI);
      }

      // Format number to specified decimal places
      function formatNumber(num, dp = 2) {
        if (typeof num !== "number" || isNaN(num)) return "";
        // Avoid negative zero
        const rounded = parseFloat(num.toFixed(dp));
        return rounded === 0
          ? "0" + (dp > 0 ? "." + "0".repeat(dp) : "")
          : rounded.toString();
        //return num.toFixed(dp);
      }

      // Format angle (degrees decimal) to degrees and minutes (robust)
      function formatAngleDegMin(degrees) {
        if (typeof degrees !== "number" || isNaN(degrees)) return "";
        if (degrees < 0 || degrees >= 360)
          console.warn("Formatting angle outside typical range:", degrees); // Warning for unusual angles

        const totalMinutes = degrees * 60;
        const roundedTotalMinutes = Math.round(totalMinutes); // Round total minutes

        const deg = Math.floor(roundedTotalMinutes / 60);
        const minutes = roundedTotalMinutes % 60;

        return `${deg}° ${minutes}'`;
      }

      // Get a random integer between min and max (inclusive)
      function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      // Get a random float between min and max
      function getRandomFloat(min, max, dp = 1) {
        const value = Math.random() * (max - min) + min;
        return parseFloat(value.toFixed(dp));
      }

      // Render Math using KaTeX - Added check for function existence
      function renderMath(element) {
        // Check if renderMathInElement is available (scripts loaded)
        if (typeof renderMathInElement === "function") {
          try {
            renderMathInElement(element, {
              delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true },
              ],
              throwOnError: false, // Avoid breaking the page on KaTeX errors
            });
          } catch (error) {
            console.error("KaTeX rendering error:", error);
            // Display error message inside the element if rendering fails
            element.innerHTML +=
              "<p style='color: red; font-size: small;'>Error al renderizar la fórmula matemática.</p>";
          }
        } else {
          // Function not loaded yet or failed to load - log warning
          console.warn(
            "KaTeX auto-render function (renderMathInElement) not loaded."
          );
        }
      }

      // Clear feedback and input
      function clearFeedbackAndInput() {
        feedbackDiv.innerHTML = "";
        feedbackDiv.className = "";
        answerInput.value = "";
        procedureArea.value = ""; // Clear procedure area too
      }

      // Enable/Disable buttons
      function setButtonsState(problemGenerated) {
        checkButton.disabled = !problemGenerated;
        newProblemButton.disabled = !selectedTopic;
        prevProblemButton.disabled = !previousProblem; // Enable only if there's a previous problem state
      }

      // --- Problem Generation Logic ---

      function generateProblem() {
        // Save current state to previous before generating new
        if (currentProblem) {
          // Make sure not to save null/initial state as previousProblem
          if (
            currentProblem.questionText &&
            currentProblem.questionText !== "Selecciona un tema para empezar."
          ) {
            previousProblem = { ...currentProblem }; // Shallow copy is fine here
            previousUserAnswer = answerInput.value;
            previousProcedure = procedureArea.value; // Save procedure too
          }
        }

        clearFeedbackAndInput();
        if (!selectedTopic) {
          problemDisplay.textContent = "Por favor, selecciona un tema primero.";
          setButtonsState(false);
          prevProblemButton.disabled = true; // Ensure prev is disabled if no topic selected
          return;
        }

        let problemData = null;
        try {
          // Add try-catch around generation in case of errors
          switch (selectedTopic) {
            case "fundamental": // Changed from 'basic'
              problemData = generateFundamentalTrigProblem();
              break;
            case "reciprocal":
              problemData = generateReciprocalProblem();
              break;
            case "complementary":
              problemData = generateComplementaryProblem();
              break;
            case "sine":
              problemData = generateSineLawProblem();
              break;
            case "cosine":
              problemData = generateCosineLawProblem();
              break;
            default:
              problemDisplay.textContent = "Tema no reconocido.";
              setButtonsState(false);
              return;
          }

          if (!problemData || !problemData.questionText) {
            // Check if problem data is valid
            throw new Error(
              "Problem generation failed or returned invalid data for topic: " +
                selectedTopic
            );
          }

          currentProblem = problemData;
          problemDisplay.innerHTML = currentProblem.questionText; // Use innerHTML for KaTeX
          renderMath(problemDisplay); // Render math in the new problem
          setButtonsState(true); // Enable Check/New buttons
        } catch (error) {
          console.error("Error generating problem:", error);
          problemDisplay.innerHTML =
            '<p style="color:red;">Error al generar el problema. Por favor, intenta seleccionar el tema de nuevo o recarga la página.</p>';
          currentProblem = null; // Reset current problem on error
          setButtonsState(false); // Disable check button
          newProblemButton.disabled = !!selectedTopic; // Keep New Problem enabled if topic selected
          prevProblemButton.disabled = !previousProblem; // Keep prev state
        }
      }

      // --- Specific Problem Generation Functions ---

      // =============================================================
      // NEW: Funciones Trigonométricas Fundamentales (SOH CAH TOA)
      // =============================================================
      function generateFundamentalTrigProblem() {
        const problemType = getRandomInt(1, 2); // 1: Find side, 2: Find angle
        let questionText = "";
        let correctAnswer = null;
        let explanation = "";
        let answerFormat = "";

        const units = ["cm", "m"][getRandomInt(0, 1)];
        const angleSymbol = "\\theta"; // Or could use A, B, etc.

        if (problemType === 1) {
          // Find side (like Task 5.1 Q3)
          answerFormat = "decimal"; // Sides are usually decimals
          const angle = getRandomInt(20, 70);
          const angleRad = degToRad(angle);

          // Define sides relative to the angle
          const sides = ["opposite", "adjacent", "hypotenuse"];
          const knownSideType = sides[getRandomInt(0, 2)];
          let unknownSideType = sides[getRandomInt(0, 2)];
          while (unknownSideType === knownSideType) {
            unknownSideType = sides[getRandomInt(0, 2)];
          }

          // Assign value to known side (ensure hypotenuse is largest if involved)
          let knownValue;
          if (knownSideType === "hypotenuse") {
            knownValue = getRandomFloat(10, 50, 1);
          } else {
            // If hypotenuse is unknown, known side can be smaller
            if (unknownSideType === "hypotenuse") {
              knownValue = getRandomFloat(5, 30, 1);
            } else {
              // opp/adj known, hyp not involved or known
              knownValue = getRandomFloat(5, 40, 1);
              // If hypotenuse is known, ensure opp/adj < hyp
              if (
                knownSideType !== "hypotenuse" &&
                unknownSideType === "hypotenuse"
              ) {
                // This case shouldn't happen based on selection, but as fallback:
                // knownValue = Math.min(knownValue, hypotenuseValue * 0.9);
              } else if (
                knownSideType === "hypotenuse" &&
                unknownSideType !== "hypotenuse"
              ) {
                //This case is handled when hyp is knownValue
              }
            }
          }

          let trigFunc = "";
          let calculation;
          let explanationParts = [];

          explanationParts.push(`<div class="explanation-step">Identificamos los lados respecto al ángulo ${angleSymbol}=${angle}°:
                     <ul>
                        <li>Lado Conocido: ${knownSideType} = ${knownValue} ${units}</li>
                        <li>Lado a Calcular: ${unknownSideType} (llamémoslo $x$)</li>
                     </ul>
                 </div>`);

          // Determine function and calculate
          if (
            (knownSideType === "opposite" &&
              unknownSideType === "hypotenuse") ||
            (knownSideType === "hypotenuse" && unknownSideType === "opposite")
          ) {
            trigFunc = "sin";
            explanationParts.push(
              `<div class="explanation-step">La función que relaciona opuesto y hipotenusa es Seno (SOH): $$\\sin(${angleSymbol}) = \\frac{\\text{opuesto}}{\\text{hipotenusa}}$$</div>`
            );
            if (knownSideType === "opposite") {
              // Known Opp, Find Hyp (x)
              calculation = knownValue / Math.sin(angleRad);
              explanationParts.push(
                `<div class="explanation-step">Sustituimos: $$\\sin(${angle}^\\circ) = \\frac{${knownValue}}{x}$$</div>`
              );
              explanationParts.push(
                `<div class="explanation-step">Despejamos $x$: $$x = \\frac{${knownValue}}{\\sin(${angle}^\\circ)} \\approx \\frac{${knownValue}}{${formatNumber(
                  Math.sin(angleRad),
                  4
                )}}$$</div>`
              );
            } else {
              // Known Hyp, Find Opp (x)
              calculation = knownValue * Math.sin(angleRad);
              explanationParts.push(
                `<div class="explanation-step">Sustituimos: $$\\sin(${angle}^\\circ) = \\frac{x}{${knownValue}}$$</div>`
              );
              explanationParts.push(
                `<div class="explanation-step">Despejamos $x$: $$x = ${knownValue} \\times \\sin(${angle}^\\circ) \\approx ${knownValue} \\times ${formatNumber(
                  Math.sin(angleRad),
                  4
                )}$$</div>`
              );
            }
          } else if (
            (knownSideType === "adjacent" &&
              unknownSideType === "hypotenuse") ||
            (knownSideType === "hypotenuse" && unknownSideType === "adjacent")
          ) {
            trigFunc = "cos";
            explanationParts.push(
              `<div class="explanation-step">La función que relaciona adyacente y hipotenusa es Coseno (CAH): $$\\cos(${angleSymbol}) = \\frac{\\text{adyacente}}{\\text{hipotenusa}}$$</div>`
            );
            if (knownSideType === "adjacent") {
              // Known Adj, Find Hyp (x)
              calculation = knownValue / Math.cos(angleRad);
              explanationParts.push(
                `<div class="explanation-step">Sustituimos: $$\\cos(${angle}^\\circ) = \\frac{${knownValue}}{x}$$</div>`
              );
              explanationParts.push(
                `<div class="explanation-step">Despejamos $x$: $$x = \\frac{${knownValue}}{\\cos(${angle}^\\circ)} \\approx \\frac{${knownValue}}{${formatNumber(
                  Math.cos(angleRad),
                  4
                )}}$$</div>`
              );
            } else {
              // Known Hyp, Find Adj (x)
              calculation = knownValue * Math.cos(angleRad);
              explanationParts.push(
                `<div class="explanation-step">Sustituimos: $$\\cos(${angle}^\\circ) = \\frac{x}{${knownValue}}$$</div>`
              );
              explanationParts.push(
                `<div class="explanation-step">Despejamos $x$: $$x = ${knownValue} \\times \\cos(${angle}^\\circ) \\approx ${knownValue} \\times ${formatNumber(
                  Math.cos(angleRad),
                  4
                )}$$</div>`
              );
            }
          } else {
            // Must be Opposite and Adjacent
            trigFunc = "tan";
            explanationParts.push(
              `<div class="explanation-step">La función que relaciona opuesto y adyacente es Tangente (TOA): $$\\tan(${angleSymbol}) = \\frac{\\text{opuesto}}{\\text{adyacente}}$$</div>`
            );
            if (knownSideType === "opposite") {
              // Known Opp, Find Adj (x)
              calculation = knownValue / Math.tan(angleRad);
              explanationParts.push(
                `<div class="explanation-step">Sustituimos: $$\\tan(${angle}^\\circ) = \\frac{${knownValue}}{x}$$</div>`
              );
              explanationParts.push(
                `<div class="explanation-step">Despejamos $x$: $$x = \\frac{${knownValue}}{\\tan(${angle}^\\circ)} \\approx \\frac{${knownValue}}{${formatNumber(
                  Math.tan(angleRad),
                  4
                )}}$$</div>`
              );
            } else {
              // Known Adj, Find Opp (x)
              calculation = knownValue * Math.tan(angleRad);
              explanationParts.push(
                `<div class="explanation-step">Sustituimos: $$\\tan(${angle}^\\circ) = \\frac{x}{${knownValue}}$$</div>`
              );
              explanationParts.push(
                `<div class="explanation-step">Despejamos $x$: $$x = ${knownValue} \\times \\tan(${angle}^\\circ) \\approx ${knownValue} \\times ${formatNumber(
                  Math.tan(angleRad),
                  4
                )}$$</div>`
              );
            }
          }

          correctAnswer = formatNumber(calculation, 2); // Format side length to 2 decimal places
          questionText = `En un triángulo rectángulo, un ángulo agudo mide ${angleSymbol} = ${angle}° y el lado ${knownSideType} mide ${knownValue} ${units}. Calcula la longitud del lado ${unknownSideType}. (Redondea a 2 decimales)`;
          explanationParts.push(
            `<div class="explanation-step">Calculando el valor: $$x \\approx ${correctAnswer}$$</div>`
          );
          explanation = explanationParts.join("");
        } else {
          // Find angle (like Task 5.1 Q5)
          answerFormat = "angle_deg_min"; // Angles in degrees and minutes

          // Define known sides
          const knownSidePairs = [
            ["opposite", "hypotenuse"],
            ["adjacent", "hypotenuse"],
            ["opposite", "adjacent"],
          ];
          const [side1Type, side2Type] = knownSidePairs[getRandomInt(0, 2)];

          // Assign values (ensure validity)
          let side1Value, side2Value;
          if (side2Type === "hypotenuse") {
            // side1 is opp or adj
            side2Value = getRandomFloat(10, 50, 1); // Hypotenuse
            side1Value = getRandomFloat(5, side2Value * 0.9, 1); // Opp/Adj must be smaller
          } else {
            // side1 is opp, side2 is adj
            side1Value = getRandomFloat(5, 40, 1);
            side2Value = getRandomFloat(5, 40, 1);
          }

          let ratio;
          let trigFunc = "";
          let inverseFunc = "";
          let explanationParts = [];

          explanationParts.push(`<div class="explanation-step">Identificamos los lados conocidos respecto al ángulo ${angleSymbol} a calcular:
                     <ul>
                        <li>Lado ${side1Type} = ${side1Value} ${units}</li>
                        <li>Lado ${side2Type} = ${side2Value} ${units}</li>
                     </ul>
                 </div>`);

          if (side1Type === "opposite" && side2Type === "hypotenuse") {
            trigFunc = "sin";
            inverseFunc = "arcsin";
            ratio = side1Value / side2Value;
            explanationParts.push(
              `<div class="explanation-step">Usamos la función Seno (SOH): $$\\sin(${angleSymbol}) = \\frac{\\text{opuesto}}{\\text{hipotenusa}} = \\frac{${side1Value}}{${side2Value}} \\approx ${formatNumber(
                ratio,
                4
              )}$$</div>`
            );
          } else if (side1Type === "adjacent" && side2Type === "hypotenuse") {
            trigFunc = "cos";
            inverseFunc = "arccos";
            ratio = side1Value / side2Value;
            explanationParts.push(
              `<div class="explanation-step">Usamos la función Coseno (CAH): $$\\cos(${angleSymbol}) = \\frac{\\text{adyacente}}{\\text{hipotenusa}} = \\frac{${side1Value}}{${side2Value}} \\approx ${formatNumber(
                ratio,
                4
              )}$$</div>`
            );
          } else {
            // opposite and adjacent
            trigFunc = "tan";
            inverseFunc = "arctan";
            ratio = side1Value / side2Value;
            explanationParts.push(
              `<div class="explanation-step">Usamos la función Tangente (TOA): $$\\tan(${angleSymbol}) = \\frac{\\text{opuesto}}{\\text{adyacente}} = \\frac{${side1Value}}{${side2Value}} \\approx ${formatNumber(
                ratio,
                4
              )}$$</div>`
            );
          }

          // Clamp ratio to avoid Math errors due to float inaccuracy, esp. for sin/cos
          ratio = Math.max(-1, Math.min(1, ratio));

          let angleRad;
          if (trigFunc === "sin") angleRad = Math.asin(ratio);
          else if (trigFunc === "cos") angleRad = Math.acos(ratio);
          else angleRad = Math.atan(ratio);

          const angleDeg = radToDeg(angleRad);
          correctAnswer = formatAngleDegMin(angleDeg);

          questionText = `En un triángulo rectángulo, el lado ${side1Type} mide ${side1Value} ${units} y el lado ${side2Type} mide ${side2Value} ${units}. Calcula la medida del ángulo agudo ${angleSymbol} definido por estos lados (si aplica) o el ángulo opuesto al lado ${side1Type} (si ${side2Type} es hipotenusa). (Respuesta en grados y minutos)`;
          explanationParts.push(
            `<div class="explanation-step">Para encontrar el ángulo, usamos la función inversa ${inverseFunc}: $${angleSymbol} = ${inverseFunc}\\left( ${formatNumber(
              ratio,
              4
            )} \\right)$$</div>`
          );
          explanationParts.push(
            `<div class="explanation-step">Calculando el valor: $${angleSymbol} \\approx ${formatNumber(
              angleDeg,
              2
            )}^\\circ$</div>`
          );
          explanationParts.push(
            `<div class="explanation-step">Convirtiendo a grados y minutos: $${angleSymbol} \\approx ${correctAnswer}$</div>`
          );
          explanation = explanationParts.join("");
        }

        return {
          questionText,
          correctAnswer,
          type: "fundamental", // Match the data-topic
          explanation,
          answerFormat,
        };
      }

      // [ ... Keep the generateReciprocalProblem, generateComplementaryProblem, generateSineLawProblem, generateCosineLawProblem functions exactly as they were ... ]
      // 2. Reciprocal Functions
      function generateReciprocalProblem() {
        const type = getRandomInt(1, 4);
        let questionText = "";
        let correctAnswer = null;
        let explanation = "";
        const angle = getRandomInt(20, 70);
        const angleRad = degToRad(angle);
        let value, calcValue;

        switch (type) {
          case 1: // Calculate csc
            value = Math.sin(angleRad);
            // Ensure value is not too close to zero to avoid huge csc
            if (Math.abs(value) < 0.1) value = 0.1 * Math.sign(value);
            calcValue = 1 / value;
            correctAnswer = formatNumber(calcValue);
            questionText = `Calcula $\\csc(${angle}^\\circ)$. (Redondea a 2 decimales)`;
            explanation = `Usamos la definición $\\csc(\\theta) = \\frac{1}{\\sin(\\theta)}$.
                                    $$\\csc(${angle}^\\circ) = \\frac{1}{\\sin(${angle}^\\circ)} \\approx \\frac{1}{${formatNumber(
              value,
              4
            )}} \\approx ${correctAnswer}$$`;
            break;
          case 2: // Calculate sec
            value = Math.cos(angleRad);
            if (Math.abs(value) < 0.1) value = 0.1 * Math.sign(value);
            calcValue = 1 / value;
            correctAnswer = formatNumber(calcValue);
            questionText = `Calcula $\\sec(${angle}^\\circ)$. (Redondea a 2 decimales)`;
            explanation = `Usamos la definición $\\sec(\\theta) = \\frac{1}{\\cos(\\theta)}$.
                                    $$\\sec(${angle}^\\circ) = \\frac{1}{\\cos(${angle}^\\circ)} \\approx \\frac{1}{${formatNumber(
              value,
              4
            )}} \\approx ${correctAnswer}$$`;
            break;
          case 3: // Calculate cot
            value = Math.tan(angleRad);
            if (Math.abs(value) < 0.01) value = 0.01 * Math.sign(value); // Avoid near-zero tan for cot
            calcValue = 1 / value;
            correctAnswer = formatNumber(calcValue);
            questionText = `Calcula $\\cot(${angle}^\\circ)$. (Redondea a 2 decimales)`;
            explanation = `Usamos la definición $\\cot(\\theta) = \\frac{1}{\\tan(\\theta)}$.
                                    $$\\cot(${angle}^\\circ) = \\frac{1}{\\tan(${angle}^\\circ)} \\approx \\frac{1}{${formatNumber(
              value,
              4
            )}} \\approx ${correctAnswer}$$`;
            break;
          case 4: // Solve simple reciprocal equation, e.g., sec(theta) = k
            const k = getRandomFloat(1.1, 3.0); // sec and csc must be >= 1 or <= -1
            const func = ["sec", "csc"][getRandomInt(0, 1)];
            let targetFunc, targetValRad, targetValDeg;

            if (func === "sec") {
              targetFunc = "cos";
              targetValRad = Math.acos(1 / k);
              questionText = `Encuentra el ángulo agudo $\\theta$ si $\\sec(\\theta) = ${formatNumber(
                k
              )}$. Da la respuesta en grados, redondeada a 1 decimal.`;
              explanation = `Si $\\sec(\\theta) = ${formatNumber(
                k
              )}$, entonces $\\cos(\\theta) = \\frac{1}{\\sec(\\theta)} = \\frac{1}{${formatNumber(
                k
              )}} \\approx ${formatNumber(1 / k, 4)}$.
                                         Para encontrar $\\theta$, usamos la función inversa del coseno:
                                         $$\\theta = \\arccos\\left( \\frac{1}{${formatNumber(
                                           k
                                         )}} \\right) \\approx \\arccos(${formatNumber(
                1 / k,
                4
              )}) $$`;
            } else {
              // csc
              targetFunc = "sin";
              targetValRad = Math.asin(1 / k);
              questionText = `Encuentra el ángulo agudo $\\theta$ si $\\csc(\\theta) = ${formatNumber(
                k
              )}$. Da la respuesta en grados, redondeada a 1 decimal.`;
              explanation = `Si $\\csc(\\theta) = ${formatNumber(
                k
              )}$, entonces $\\sin(\\theta) = \\frac{1}{\\csc(\\theta)} = \\frac{1}{${formatNumber(
                k
              )}} \\approx ${formatNumber(1 / k, 4)}$.
                                         Para encontrar $\\theta$, usamos la función inversa del seno:
                                         $$\\theta = \\arcsin\\left( \\frac{1}{${formatNumber(
                                           k
                                         )}} \\right) \\approx \\arcsin(${formatNumber(
                1 / k,
                4
              )}) $$`;
            }
            targetValDeg = radToDeg(targetValRad);
            correctAnswer = formatNumber(targetValDeg, 1);
            explanation += `$$\\theta \\approx ${correctAnswer}^\\circ$$`;
            break;
        }

        return {
          questionText,
          correctAnswer,
          type: "reciprocal",
          explanation,
          answerFormat: type === 4 ? "angle_deg_1dp" : "decimal",
        };
      }

      // 3. Complementary Angles
      function generateComplementaryProblem() {
        const type = getRandomInt(1, 3);
        let questionText = "";
        let correctAnswer = null;
        let explanation = "";
        const angle1 = getRandomInt(10, 80);
        const angle2 = 90 - angle1;

        switch (type) {
          case 1: // Simplify sin(a)/cos(90-a) or cos(a)/sin(90-a) etc.
            const funcs = [
              ["sin", "cos"],
              ["cos", "sin"],
              ["tan", "cot"],
              ["cot", "tan"],
            ];
            const [f1, f2] = funcs[getRandomInt(0, 3)];
            correctAnswer = "1"; // Always simplifies to 1
            questionText = `Simplifica la expresión: $$\\frac{${f1}(${angle1}^\\circ)}{${f2}(${angle2}^\\circ)}$$`;
            explanation = `Recordamos las identidades de ángulos complementarios:
                                   $${f2}(x) = ${f1}(90^\\circ - x)$ o $${f1}(x) = ${f2}(90^\\circ - x)$.
                                   En este caso, ${angle2}^\\circ = 90^\\circ - ${angle1}^\\circ$.
                                   Así que, $${f2}(${angle2}^\\circ) = ${f1}(${angle1}^\\circ)$.
                                   Sustituyendo en la expresión original:
                                   $$\\frac{${f1}(${angle1}^\\circ)}{${f1}(${angle1}^\\circ)} = 1$$`;
            break;
          case 2: // Solve equation like sin(A) = cos(B) where A and B are linear expressions
            let c1, c2, k1, k2, x;
            let attempts = 0;
            do {
              c1 = getRandomInt(1, 3);
              c2 = getRandomInt(1, 3);
              k1 = getRandomInt(-20, 20);
              k2 = getRandomInt(-20, 20);
              if (c1 + c2 === 0) continue; // Avoid division by zero
              x = (90 - k1 - k2) / (c1 + c2);
              attempts++;
              // Check if x is reasonable and resulting angles are positive acute
              if (
                x > 0 &&
                x < 40 &&
                c1 * x + k1 > 0 &&
                c1 * x + k1 < 90 &&
                c2 * x + k2 > 0 &&
                c2 * x + k2 < 90
              ) {
                break; // Found a good set
              }
            } while (attempts < 20); // Limit attempts

            // Fallback if no good solution found
            if (attempts >= 20 || x <= 0 || x >= 40 || isNaN(x)) {
              c1 = 2;
              k1 = 10; // 2x+10 = 50
              c2 = 1;
              k2 = 20; // x+20 = 40
              x = (90 - k1 - k2) / (c1 + c2); // x = 20
            }

            const expr1 = `${c1}x ${k1 >= 0 ? "+" : ""} ${k1}`;
            const expr2 = `${c2}x ${k2 >= 0 ? "+" : ""} ${k2}`;
            questionText = `Encuentra el valor de $x$ si $\\sin(${expr1})^\\circ = \\cos(${expr2})^\\circ$.`;
            correctAnswer = formatNumber(x, 1); // Allow one decimal place for x if needed
            explanation = `Si $\\sin(A) = \\cos(B)$, y A y B son ángulos agudos, entonces $A + B = 90^\\circ$.
                                     En este caso, $A = (${expr1})^\\circ$ y $B = (${expr2})^\\circ$.
                                     $$((${expr1}) + (${expr2}))^\\circ = 90^\\circ$$
                                     $$(${c1 + c2})x + (${k1 + k2}) = 90$$
                                     $$${c1 + c2}x = 90 - (${k1 + k2})$$
                                     $$${c1 + c2}x = ${90 - (k1 + k2)}$$
                                     $$x = \\frac{${90 - (k1 + k2)}}{${
              c1 + c2
            }} = ${correctAnswer}$$`;
            break;

          case 3: // Evaluate expression using complementary angles
            const a = getRandomInt(15, 40);
            const b = 90 - a;
            const c = getRandomInt(15, 40); // Different angle
            // Example: tan(a)tan(90-a) or sin^2(a) + sin^2(90-a)
            const exprType = getRandomInt(1, 2);
            if (exprType === 1) {
              // tan(a)tan(b) or cot(a)cot(b)
              const func = ["tan", "cot"][getRandomInt(0, 1)];
              correctAnswer = "1";
              questionText = `Evalúa: $${func}(${a}^\\circ) \\times ${func}(${b}^\\circ)$`;
              explanation = `Recordamos que $\\tan(90^\\circ - x) = \\cot(x)$ y $\\cot(90^\\circ - x) = \\tan(x)$.
                                        Si usamos ${func}, tenemos ${func}(${b}^\\circ) = ${func}(90^\\circ - ${a}^\\circ)$.
                                        Si ${func} es 'tan', $\\tan(${b}^\\circ) = \\cot(${a}^\\circ) = \\frac{1}{\\tan(${a}^\\circ)}$.
                                        Si ${func} es 'cot', $\\cot(${b}^\\circ) = \\tan(${a}^\\circ) = \\frac{1}{\\cot(${a}^\\circ)}$.
                                        En ambos casos, la expresión se convierte en:
                                        $$${func}(${a}^\\circ) \\times \\frac{1}{${func}(${a}^\\circ)} = 1$$`;
            } else {
              // sin^2(a) + sin^2(b) or cos^2(a) + cos^2(b)
              const func = ["sin", "cos"][getRandomInt(0, 1)];
              correctAnswer = "1";
              questionText = `Evalúa: $${func}^2(${a}^\\circ) + ${func}^2(${b}^\\circ)$`;
              explanation = `Recordamos que $\\sin(90^\\circ - x) = \\cos(x)$ y $\\cos(90^\\circ - x) = \\sin(x)$.
                                        Tenemos $${func}(${b}^\\circ) = ${func}(90^\\circ - ${a}^\\circ)$.
                                        Si ${func} es 'sin', $\\sin(${b}^\\circ) = \\cos(${a}^\\circ)$. La expresión es $\\sin^2(${a}^\\circ) + \\cos^2(${a}^\\circ)$.
                                        Si ${func} es 'cos', $\\cos(${b}^\\circ) = \\sin(${a}^\\circ)$. La expresión es $\\cos^2(${a}^\\circ) + \\sin^2(${a}^\\circ)$.
                                        Usando la identidad pitagórica fundamental $\\sin^2(\\theta) + \\cos^2(\\theta) = 1$, el resultado es 1.
                                        $$${func}^2(${a}^\\circ) + ${
                func === "sin" ? "\\cos" : "\\sin"
              }^2(${a}^\\circ) = 1$$`;
            }
            break;
        }

        return {
          questionText,
          correctAnswer,
          type: "complementary",
          explanation,
          answerFormat: type === 2 ? "decimal_1dp" : "integer",
        };
      }

      // 4. Sine Law
      function generateSineLawProblem() {
        // Cases: AAS, ASA (SSA is ambiguous, maybe avoid for simplicity or add later)
        const type = getRandomInt(1, 3); // 1: Find side (AAS), 2: Find side (ASA), 3: Find angle (given 2 sides 1 opp angle)
        let questionText = "";
        let correctAnswer = null;
        let explanation = "";

        // Triangle labels: Angles A, B, C; Opposite sides a, b, c
        let A, B, C, a, b, c;
        let knownA, knownB, knownC, known_a, known_b, known_c;
        let findSide = null; // 'a', 'b', or 'c'
        let findAngle = null; // 'A', 'B', or 'C'

        switch (type) {
          case 1: // Find side given AAS
            findSide = ["a", "b", "c"][getRandomInt(0, 2)];
            knownA = getRandomInt(30, 80);
            knownB = getRandomInt(30, 140 - knownA); // Ensure A+B < 150 (leaves room for C)
            knownC = 180 - knownA - knownB;

            // Assign one known side opposite one known angle
            const knownSideIndex = getRandomInt(0, 2); // Which side is known
            const knownAngle = [knownA, knownB, knownC][knownSideIndex];
            const knownSideLabel = ["a", "b", "c"][knownSideIndex];
            const knownSideValue = getRandomFloat(10, 50);

            if (knownSideLabel === "a") known_a = knownSideValue;
            if (knownSideLabel === "b") known_b = knownSideValue;
            if (knownSideLabel === "c") known_c = knownSideValue;

            let targetAngle, targetAngleLabel;
            if (findSide === "a") {
              targetAngle = knownA;
              targetAngleLabel = "A";
            }
            if (findSide === "b") {
              targetAngle = knownB;
              targetAngleLabel = "B";
            }
            if (findSide === "c") {
              targetAngle = knownC;
              targetAngleLabel = "C";
            }

            let calcValue =
              (knownSideValue / Math.sin(degToRad(knownAngle))) *
              Math.sin(degToRad(targetAngle));
            correctAnswer = formatNumber(calcValue);

            questionText = `En un triángulo $\\triangle ABC$, el ángulo $A = ${knownA}^\\circ$, el ángulo $B = ${knownB}^\\circ$, y el lado ${knownSideLabel} = ${knownSideValue}$ cm. Calcula la longitud del lado ${findSide}. (Redondea a 2 decimales)`;
            explanation = `Primero, encontramos el tercer ángulo: $C = 180^\\circ - A - B = 180^\\circ - ${knownA}^\\circ - ${knownB}^\\circ = ${knownC}^\\circ$.
                                   Usamos la Ley de Senos: $$\\frac{a}{\\sin A} = \\frac{b}{\\sin B} = \\frac{c}{\\sin C}$$
                                   Queremos encontrar el lado ${findSide}$. Conocemos el lado ${knownSideLabel} = ${knownSideValue}$ y su ángulo opuesto ${
              ["A", "B", "C"][knownSideIndex]
            } = ${knownAngle}^\\circ$. El ángulo opuesto a ${findSide}$ es ${targetAngleLabel} = ${targetAngle}^\\circ$.
                                   Establecemos la proporción: $$\\frac{${findSide}}{\\sin(${targetAngle}^\\circ)} = \\frac{${knownSideLabel}}{\\sin(${knownAngle}^\\circ)}$$
                                   Despejando ${findSide}$: $${findSide} = \\frac{${knownSideLabel} \\times \\sin(${targetAngle}^\\circ)}{\\sin(${knownAngle}^\\circ)}$$
                                   $${findSide} = \\frac{${knownSideValue} \\times \\sin(${targetAngle}^\\circ)}{\\sin(${knownAngle}^\\circ)} \\approx \\frac{${knownSideValue} \\times ${formatNumber(
              Math.sin(degToRad(targetAngle)),
              4
            )}}{${formatNumber(
              Math.sin(degToRad(knownAngle)),
              4
            )}} \\approx ${correctAnswer} \\text{ cm}$$`;
            break;

          case 2: // Find side given ASA
            findSide = ["a", "b", "c"][getRandomInt(0, 2)];
            knownA = getRandomInt(30, 80);
            knownC = getRandomInt(30, 140 - knownA);
            knownB = 180 - knownA - knownC;
            known_a = null;
            known_b = null;
            known_c = null; // Reset known sides

            // Included side is known (b if A and C known, a if B and C known, c if A and B known)
            const includedSideIndex = getRandomInt(0, 2); // Which pair of angles determines the included side
            let sideLabel, angle1, angle2, knownSideVal;
            if (includedSideIndex === 0) {
              angle1 = knownA;
              angle2 = knownC;
              sideLabel = "b";
              known_b = getRandomFloat(10, 50);
              knownSideVal = known_b;
            } // Given A, C, side b
            else if (includedSideIndex === 1) {
              angle1 = knownB;
              angle2 = knownC;
              sideLabel = "a";
              known_a = getRandomFloat(10, 50);
              knownSideVal = known_a;
            } // Given B, C, side a
            else {
              angle1 = knownA;
              angle2 = knownB;
              sideLabel = "c";
              known_c = getRandomFloat(10, 50);
              knownSideVal = known_c;
            } // Given A, B, side c

            const knownAngle1 = angle1; // Angle adjacent 1
            const knownAngle2 = angle2; // Angle adjacent 2
            // The third angle is OPPOSITE the known included side
            const knownSideOppositeAngle = 180 - knownAngle1 - knownAngle2;
            const knownSideOppositeAngleLabel = sideLabel.toUpperCase(); // e.g., if sideLabel='b', angle is 'B'

            let targetAngleASA, targetAngleLabelASA;
            if (findSide === "a") {
              targetAngleASA = knownA;
              targetAngleLabelASA = "A";
            }
            if (findSide === "b") {
              targetAngleASA = knownB;
              targetAngleLabelASA = "B";
            }
            if (findSide === "c") {
              targetAngleASA = knownC;
              targetAngleLabelASA = "C";
            }

            calcValue =
              (knownSideVal / Math.sin(degToRad(knownSideOppositeAngle))) *
              Math.sin(degToRad(targetAngleASA));
            correctAnswer = formatNumber(calcValue);

            // Construct question text carefully based on which angles/side were chosen
            let angleLabel1Text, angleLabel2Text;
            if (sideLabel === "a") {
              angleLabel1Text = "B";
              angleLabel2Text = "C";
            } else if (sideLabel === "b") {
              angleLabel1Text = "A";
              angleLabel2Text = "C";
            } else {
              angleLabel1Text = "A";
              angleLabel2Text = "B";
            }

            questionText = `En $\\triangle ABC$, el ángulo ${angleLabel1Text} = ${knownAngle1}^\\circ$, el ángulo ${angleLabel2Text} = ${knownAngle2}^\\circ$, y el lado incluido ${sideLabel} = ${knownSideVal}$ m. Calcula la longitud del lado ${findSide}. (Redondea a 2 decimales)`;
            explanation = `Primero, encontramos el tercer ángulo (${knownSideOppositeAngleLabel}), que es opuesto al lado conocido ${sideLabel}: ${knownSideOppositeAngleLabel} = 180^\\circ - ${knownAngle1}^\\circ - ${knownAngle2}^\\circ = ${knownSideOppositeAngle}^\\circ$.
                                    Usamos la Ley de Senos: $$\\frac{a}{\\sin A} = \\frac{b}{\\sin B} = \\frac{c}{\\sin C}$$
                                    Queremos encontrar ${findSide}$. Conocemos el lado ${sideLabel} = ${knownSideVal}$ y su ángulo opuesto ${knownSideOppositeAngleLabel} = ${knownSideOppositeAngle}^\\circ$. El ángulo opuesto a ${findSide}$ es ${targetAngleLabelASA} = ${targetAngleASA}^\\circ$.
                                    Establecemos la proporción: $$\\frac{${findSide}}{\\sin(${targetAngleASA}^\\circ)} = \\frac{${sideLabel}}{\\sin(${knownSideOppositeAngle}^\\circ)}$$
                                    Despejando ${findSide}$: $${findSide} = \\frac{${sideLabel} \\times \\sin(${targetAngleASA}^\\circ)}{\\sin(${knownSideOppositeAngle}^\\circ)}$$
                                    $${findSide} = \\frac{${knownSideVal} \\times \\sin(${targetAngleASA}^\\circ)}{\\sin(${knownSideOppositeAngle}^\\circ)} \\approx \\frac{${knownSideVal} \\times ${formatNumber(
              Math.sin(degToRad(targetAngleASA)),
              4
            )}}{${formatNumber(
              Math.sin(degToRad(knownSideOppositeAngle)),
              4
            )}} \\approx ${correctAnswer} \\text{ m}$$`;
            break;

          case 3: // Find angle given SSA (Ensure non-ambiguous case for simplicity: side opp known angle > other known side)
            findAngle = ["A", "B", "C"][getRandomInt(0, 2)]; // Which angle to find

            // Define known side opposite known angle, and another known side
            let knownAngleSSA,
              knownSideOpp,
              otherKnownSide,
              otherKnownSideLabel;
            let attempts = 0;
            do {
              knownAngleSSA = getRandomInt(30, 80);
              knownSideOpp = getRandomFloat(15, 40); // Side opposite known angle
              otherKnownSide = getRandomFloat(10, knownSideOpp - 1); // Other side (must be < knownSideOpp for non-ambiguous)
              attempts++;
              // Check if sin(TargetAngle) = (otherKnownSide * sin(knownAngleSSA)) / knownSideOpp is <= 1
              const sinValCheck =
                (otherKnownSide * Math.sin(degToRad(knownAngleSSA))) /
                knownSideOpp;
              if (sinValCheck > 0 && sinValCheck <= 1) break; // Check it's valid sin value > 0 and <= 1
            } while (attempts < 20);
            if (attempts >= 20) {
              // Fallback if random generation fails
              knownAngleSSA = 45;
              knownSideOpp = 20;
              otherKnownSide = 15;
              console.warn(
                "SSA generation failed, using fallback A=45, a=20, b=15"
              );
            }

            // Assign labels (e.g., known A, a, b -> find B)
            const knownAngleLabelSSA = ["A", "B", "C"][getRandomInt(0, 2)];
            const knownSideOppLabel = knownAngleLabelSSA.toLowerCase();
            let otherKnownSideLabelIndex = getRandomInt(0, 2);
            while (
              otherKnownSideLabelIndex ===
              ["A", "B", "C"].indexOf(knownAngleLabelSSA)
            ) {
              otherKnownSideLabelIndex = getRandomInt(0, 2); // Ensure different side
            }
            otherKnownSideLabel = ["a", "b", "c"][otherKnownSideLabelIndex];

            // The angle to find is opposite the otherKnownSide
            findAngle = otherKnownSideLabel.toUpperCase();

            // Calculate the target angle
            const sinTargetAngle =
              (otherKnownSide * Math.sin(degToRad(knownAngleSSA))) /
              knownSideOpp;
            // Clamp value to [0, 1] since we expect acute angle result here
            const clampedSinTargetAngle = Math.max(
              0,
              Math.min(1, sinTargetAngle)
            );
            const targetAngleRad = Math.asin(clampedSinTargetAngle);
            const targetAngleDeg = radToDeg(targetAngleRad);
            correctAnswer = formatAngleDegMin(targetAngleDeg); // Format as Deg° Min'

            questionText = `En $\\triangle ABC$, el ángulo ${knownAngleLabelSSA} = ${knownAngleSSA}^\\circ$, el lado ${knownSideOppLabel} = ${knownSideOpp}$ cm, y el lado ${otherKnownSideLabel} = ${otherKnownSide}$ cm. Calcula la medida del ángulo ${findAngle}. (Da la respuesta en grados y minutos)`;
            explanation = `Usamos la Ley de Senos: $$\\frac{a}{\\sin A} = \\frac{b}{\\sin B} = \\frac{c}{\\sin C}$$
                                    Conocemos el ángulo ${knownAngleLabelSSA} = ${knownAngleSSA}^\\circ$ y su lado opuesto ${knownSideOppLabel} = ${knownSideOpp}$.
                                    También conocemos el lado ${otherKnownSideLabel} = ${otherKnownSide}$. Queremos encontrar el ángulo opuesto ${findAngle}$.
                                    Establecemos la proporción: $$\\frac{${otherKnownSideLabel}}{\\sin(${findAngle})} = \\frac{${knownSideOppLabel}}{\\sin(${knownAngleLabelSSA})}$$
                                    Despejando $\\sin(${findAngle})$: $$\\sin(${findAngle}) = \\frac{${otherKnownSideLabel} \\times \\sin(${knownAngleLabelSSA}^\\circ)}{\\text{${knownSideOppLabel}}}$$
                                    $$\\sin(${findAngle}) = \\frac{${otherKnownSide} \\times \\sin(${knownAngleSSA}^\\circ)}{${knownSideOpp}} \\approx \\frac{${otherKnownSide} \\times ${formatNumber(
              Math.sin(degToRad(knownAngleSSA)),
              4
            )}}{${knownSideOpp}} \\approx ${formatNumber(sinTargetAngle, 4)}$$
                                    Para encontrar ${findAngle}$, usamos la función inversa del seno:
                                    $${findAngle} = \\arcsin(${formatNumber(
              sinTargetAngle,
              4
            )}) \\approx ${formatNumber(targetAngleDeg, 2)}^\\circ$$
                                    Convirtiendo a grados y minutos: $${findAngle} \\approx ${correctAnswer}$$`;
            break;
        }

        return {
          questionText,
          correctAnswer,
          type: "sine",
          explanation,
          answerFormat: type === 3 ? "angle_deg_min" : "decimal",
        };
      }

      // 5. Cosine Law
      function generateCosineLawProblem() {
        // Cases: SAS (find opposite side), SSS (find an angle)
        const type = getRandomInt(1, 2);
        let questionText = "";
        let correctAnswer = null;
        let explanation = "";

        // Triangle labels: Angles A, B, C; Opposite sides a, b, c
        let A, B, C, a, b, c;

        switch (type) {
          case 1: // SAS -> Find opposite side
            const knownAngleLabel = ["A", "B", "C"][getRandomInt(0, 2)];
            const knownAngle = getRandomInt(30, 150); // Can be obtuse
            const side1Value = getRandomFloat(10, 40);
            const side2Value = getRandomFloat(10, 40);
            let side1Label, side2Label;

            // Determine side labels based on known angle
            if (knownAngleLabel === "A") {
              side1Label = "b";
              side2Label = "c";
            } else if (knownAngleLabel === "B") {
              side1Label = "a";
              side2Label = "c";
            } else {
              side1Label = "a";
              side2Label = "b";
            }

            const targetSideLabel = knownAngleLabel.toLowerCase(); // Side opposite known angle

            // Calculate target side using Cosine Law: a^2 = b^2 + c^2 - 2bc cos(A)
            let targetSideSq =
              side1Value ** 2 +
              side2Value ** 2 -
              2 * side1Value * side2Value * Math.cos(degToRad(knownAngle));

            // Ensure result is valid (targetSideSq must be positive)
            if (targetSideSq <= 0) {
              console.warn(
                "Cosine Law resulted in non-positive side squared, regenerating..."
              );
              return generateCosineLawProblem(); // Simple recursion for regeneration
            }

            const targetSideValue = Math.sqrt(targetSideSq);
            correctAnswer = formatNumber(targetSideValue);

            questionText = `En $\\triangle ABC$, el lado ${side1Label} = ${side1Value}$ cm, el lado ${side2Label} = ${side2Value}$ cm, y el ángulo incluido ${knownAngleLabel} = ${knownAngle}^\\circ$. Calcula la longitud del lado ${targetSideLabel}. (Redondea a 2 decimales)`;
            explanation = `Usamos la Ley de Cosenos para encontrar el lado opuesto a un ángulo conocido, dadas las longitudes de los otros dos lados.
                                    La fórmula general es: $a^2 = b^2 + c^2 - 2bc \\cos A$.
                                    En este caso, queremos encontrar el lado ${targetSideLabel}$. Los lados adyacentes son ${side1Label}=${side1Value}$ y ${side2Label}=${side2Value}$, y el ángulo incluido es ${knownAngleLabel}=${knownAngle}^\\circ$.
                                    La fórmula adaptada es: $${targetSideLabel}^2 = ${side1Label}^2 + ${side2Label}^2 - 2(${side1Label})(${side2Label}) \\cos(${knownAngleLabel})$$
                                    $${targetSideLabel}^2 = (${side1Value})^2 + (${side2Value})^2 - 2(${side1Value})(${side2Value}) \\cos(${knownAngle}^\\circ)$$
                                    $${targetSideLabel}^2 = ${formatNumber(
              side1Value ** 2
            )} + ${formatNumber(
              side2Value ** 2
            )} - 2(${side1Value})(${side2Value}) (${formatNumber(
              Math.cos(degToRad(knownAngle)),
              4
            )})$$
                                    $${targetSideLabel}^2 \\approx ${formatNumber(
              side1Value ** 2 + side2Value ** 2
            )} - ${formatNumber(2 * side1Value * side2Value)} (${formatNumber(
              Math.cos(degToRad(knownAngle)),
              4
            )})$$
                                    $${targetSideLabel}^2 \\approx ${formatNumber(
              targetSideSq,
              4
            )}$$
                                    $${targetSideLabel} = \\sqrt{${formatNumber(
              targetSideSq,
              4
            )}} \\approx ${correctAnswer} \\text{ cm}$$`;
            break;

          case 2: // SSS -> Find an angle
            const findAngleLabel = ["A", "B", "C"][getRandomInt(0, 2)];
            let side_a, side_b, side_c;

            // Generate 3 sides that can form a triangle
            let attempts = 0;
            do {
              side_a = getRandomFloat(10, 30);
              side_b = getRandomFloat(10, 30);
              // Ensure c is possible and avoid degenerate triangles
              const min_c = Math.max(0.1, Math.abs(side_a - side_b) + 0.1); // Must be greater than difference
              const max_c = side_a + side_b - 0.1; // Must be less than sum
              if (min_c >= max_c) {
                // If a,b are too close/far apart
                attempts++;
                continue;
              }
              side_c = getRandomFloat(min_c, max_c);

              side_a = parseFloat(side_a.toFixed(1));
              side_b = parseFloat(side_b.toFixed(1));
              side_c = parseFloat(side_c.toFixed(1));
              attempts++;
            } while (
              (side_a + side_b <= side_c ||
                side_a + side_c <= side_b ||
                side_b + side_c <= side_a) &&
              attempts < 30
            ); // Increased attempts

            if (
              attempts >= 30 ||
              side_a + side_b <= side_c ||
              side_a + side_c <= side_b ||
              side_b + side_c <= side_a
            ) {
              // Fallback if generation fails
              side_a = 10;
              side_b = 15;
              side_c = 20;
              console.warn(
                "SSS generation failed, using fallback sides 10, 15, 20."
              );
            }

            // Calculate the angle using Cosine Law: cos A = (b^2 + c^2 - a^2) / 2bc
            let cosAngleValue;
            if (findAngleLabel === "A") {
              cosAngleValue =
                (side_b ** 2 + side_c ** 2 - side_a ** 2) /
                (2 * side_b * side_c);
              explanation = `Usamos la Ley de Cosenos para encontrar un ángulo cuando se conocen los tres lados.
                                         La fórmula para encontrar el ángulo A es: $$\\cos A = \\frac{b^2 + c^2 - a^2}{2bc}$$
                                         Sustituyendo los valores dados ($a=${formatNumber(
                                           side_a
                                         )}, b=${formatNumber(
                side_b
              )}, c=${formatNumber(side_c)}$):
                                         $$\\cos A = \\frac{(${formatNumber(
                                           side_b
                                         )})^2 + (${formatNumber(
                side_c
              )})^2 - (${formatNumber(side_a)})^2}{2(${formatNumber(
                side_b
              )})(${formatNumber(side_c)})}$$
                                         $$\\cos A = \\frac{${formatNumber(
                                           side_b ** 2
                                         )} + ${formatNumber(
                side_c ** 2
              )} - ${formatNumber(side_a ** 2)}}{${formatNumber(
                2 * side_b * side_c
              )}}$$
                                         $$\\cos A = \\frac{${formatNumber(
                                           side_b ** 2 +
                                             side_c ** 2 -
                                             side_a ** 2
                                         )}}{${formatNumber(
                2 * side_b * side_c
              )}} \\approx ${formatNumber(cosAngleValue, 4)}$$`;
            } else if (findAngleLabel === "B") {
              cosAngleValue =
                (side_a ** 2 + side_c ** 2 - side_b ** 2) /
                (2 * side_a * side_c);
              explanation = `Usamos la Ley de Cosenos para encontrar un ángulo cuando se conocen los tres lados.
                                         La fórmula para encontrar el ángulo B es: $$\\cos B = \\frac{a^2 + c^2 - b^2}{2ac}$$
                                         Sustituyendo los valores dados ($a=${formatNumber(
                                           side_a
                                         )}, b=${formatNumber(
                side_b
              )}, c=${formatNumber(side_c)}$):
                                         $$\\cos B = \\frac{(${formatNumber(
                                           side_a
                                         )})^2 + (${formatNumber(
                side_c
              )})^2 - (${formatNumber(side_b)})^2}{2(${formatNumber(
                side_a
              )})(${formatNumber(side_c)})}$$
                                         $$\\cos B = \\frac{${formatNumber(
                                           side_a ** 2
                                         )} + ${formatNumber(
                side_c ** 2
              )} - ${formatNumber(side_b ** 2)}}{${formatNumber(
                2 * side_a * side_c
              )}}$$
                                         $$\\cos B = \\frac{${formatNumber(
                                           side_a ** 2 +
                                             side_c ** 2 -
                                             side_b ** 2
                                         )}}{${formatNumber(
                2 * side_a * side_c
              )}} \\approx ${formatNumber(cosAngleValue, 4)}$$`;
            } else {
              // findAngleLabel === 'C'
              cosAngleValue =
                (side_a ** 2 + side_b ** 2 - side_c ** 2) /
                (2 * side_a * side_b);
              explanation = `Usamos la Ley de Cosenos para encontrar un ángulo cuando se conocen los tres lados.
                                         La fórmula para encontrar el ángulo C es: $$\\cos C = \\frac{a^2 + b^2 - c^2}{2ab}$$
                                         Sustituyendo los valores dados ($a=${formatNumber(
                                           side_a
                                         )}, b=${formatNumber(
                side_b
              )}, c=${formatNumber(side_c)}$):
                                         $$\\cos C = \\frac{(${formatNumber(
                                           side_a
                                         )})^2 + (${formatNumber(
                side_b
              )})^2 - (${formatNumber(side_c)})^2}{2(${formatNumber(
                side_a
              )})(${formatNumber(side_b)})}$$
                                         $$\\cos C = \\frac{${formatNumber(
                                           side_a ** 2
                                         )} + ${formatNumber(
                side_b ** 2
              )} - ${formatNumber(side_c ** 2)}}{${formatNumber(
                2 * side_a * side_b
              )}}$$
                                         $$\\cos C = \\frac{${formatNumber(
                                           side_a ** 2 +
                                             side_b ** 2 -
                                             side_c ** 2
                                         )}}{${formatNumber(
                2 * side_a * side_b
              )}} \\approx ${formatNumber(cosAngleValue, 4)}$$`;
            }

            // Ensure cosAngleValue is within [-1, 1] due to potential float inaccuracies
            cosAngleValue = Math.max(-1, Math.min(1, cosAngleValue));

            const targetAngleRad = Math.acos(cosAngleValue);
            const targetAngleDeg = radToDeg(targetAngleRad);
            correctAnswer = formatAngleDegMin(targetAngleDeg); // Format as Deg° Min'

            questionText = `En $\\triangle ABC$, los lados miden $a = ${formatNumber(
              side_a
            )}$ m, $b = ${formatNumber(side_b)}$ m, y $c = ${formatNumber(
              side_c
            )}$ m. Calcula la medida del ángulo ${findAngleLabel}$. (Da la respuesta en grados y minutos)`;
            explanation += `Para encontrar el ángulo ${findAngleLabel}$, usamos la función inversa del coseno:
                                     $${findAngleLabel} = \\arccos(${formatNumber(
              cosAngleValue,
              4
            )}) \\approx ${formatNumber(targetAngleDeg, 2)}^\\circ$$
                                     Convirtiendo a grados y minutos: $${findAngleLabel} \\approx ${correctAnswer}$$`;
            break;
        }

        return {
          questionText,
          correctAnswer,
          type: "cosine",
          explanation,
          answerFormat: type === 2 ? "angle_deg_min" : "decimal",
        };
      }

      // --- Event Handlers ---

      // Topic Selection
      topicSelector.addEventListener("click", (e) => {
        if (e.target.classList.contains("topic-button")) {
          topicButtons.forEach((btn) => btn.classList.remove("active"));
          e.target.classList.add("active");
          selectedTopic = e.target.dataset.topic;
          previousProblem = null; // Reset history when topic changes
          previousUserAnswer = "";
          previousProcedure = "";
          generateProblem(); // Generate a problem for the new topic
        }
      });

      // Check Answer
      checkButton.addEventListener("click", () => {
        if (!currentProblem || checkButton.disabled) return; // Extra check

        const userAnswerStr = answerInput.value.trim();
        if (userAnswerStr === "") {
          feedbackDiv.textContent = "Por favor, introduce una respuesta.";
          feedbackDiv.className = "incorrect";
          return;
        }

        let isCorrect = false;
        const correctAnswerStr = String(currentProblem.correctAnswer).trim();

        // Comparison logic based on answer format
        if (currentProblem.answerFormat === "angle_deg_min") {
          // Allow flexible input like "45° 30'" or "45d 30m" or "45 30" etc.
          const parseDegMin = (str) => {
            // Handle potential missing minutes part gracefully
            const parts = str
              .replace(/°|d|m|'/gi, " ")
              .replace(/\s+/g, " ")
              .trim()
              .split(" ");
            const deg = parseFloat(parts[0]) || 0;
            const min = parseFloat(parts[1]) || 0;
            if (isNaN(deg) || isNaN(min)) return NaN; // Invalid format
            return deg + min / 60;
          };
          const userDeg = parseDegMin(userAnswerStr);
          const correctDeg = parseDegMin(correctAnswerStr);

          // Check if both parsed successfully
          if (!isNaN(userDeg) && !isNaN(correctDeg)) {
            // Compare in decimal degrees using minute tolerance
            isCorrect =
              Math.abs(userDeg - correctDeg) < ANGLE_MINUTE_TOLERANCE_DEG;
          } else {
            console.warn(
              "Could not parse angle input:",
              userAnswerStr,
              "or correct answer:",
              correctAnswerStr
            );
          }
        } else if (
          currentProblem.answerFormat &&
          currentProblem.answerFormat.startsWith("angle_deg")
        ) {
          // For angles just in degrees
          const userValue = parseFloat(userAnswerStr);
          const correctValue = parseFloat(correctAnswerStr);
          if (!isNaN(userValue) && !isNaN(correctValue)) {
            isCorrect = Math.abs(userValue - correctValue) < ANGLE_TOLERANCE;
          }
        } else if (currentProblem.answerFormat === "decimal_1dp") {
          const userValue = parseFloat(userAnswerStr);
          const correctValue = parseFloat(correctAnswerStr);
          if (!isNaN(userValue) && !isNaN(correctValue)) {
            // Check if numbers rounded to 1dp are the same (use 0.05 tolerance + base tolerance)
            isCorrect = Math.abs(userValue - correctValue) < 0.05 + TOLERANCE;
          }
        } else {
          // Default: decimal (2dp) or integer comparison
          const userValue = parseFloat(userAnswerStr);
          const correctValue = parseFloat(correctAnswerStr);

          if (!isNaN(userValue) && !isNaN(correctValue)) {
            // Primary check with standard tolerance
            isCorrect = Math.abs(userValue - correctValue) < TOLERANCE;

            // Specific check for integer answers (e.g., from complementary angle simplifications)
            if (
              !isCorrect &&
              currentProblem.answerFormat === "integer" &&
              Math.abs(Math.round(userValue) - correctValue) < TOLERANCE
            ) {
              isCorrect = true;
            }
            // Check if intended answer was an integer, allow rounding within tolerance
            else if (
              !isCorrect &&
              Number.isInteger(correctValue) &&
              Math.abs(userValue - correctValue) < 0.001
            ) {
              isCorrect = true;
            }
          }
          // Allow direct string comparison for things like '1' if float check fails
          if (
            !isCorrect &&
            typeof correctAnswerStr === "string" &&
            userAnswerStr.toLowerCase() === correctAnswerStr.toLowerCase()
          ) {
            isCorrect = true;
          }
        }

        if (isCorrect) {
          feedbackDiv.innerHTML = "<strong>¡Correcto!</strong> 🎉";
          feedbackDiv.className = "correct";
        } else {
          // Ensure correct answer is displayed nicely
          let displayCorrect = correctAnswerStr;
          // Use the originally formatted string for angles with minutes
          if (
            currentProblem.answerFormat !== "angle_deg_min" &&
            !isNaN(parseFloat(correctAnswerStr))
          ) {
            // Re-format potentially imprecise float correct answers for display
            let dp = 2;
            if (currentProblem.answerFormat === "decimal_1dp") dp = 1;
            else if (currentProblem.answerFormat === "integer") dp = 0;
            else if (
              currentProblem.answerFormat &&
              currentProblem.answerFormat.startsWith("angle_deg")
            )
              dp = 1; // Display degree angles with 1dp if not deg/min

            displayCorrect = formatNumber(parseFloat(correctAnswerStr), dp);
            // Add degree symbol if it's an angle format without minutes
            if (
              currentProblem.answerFormat &&
              currentProblem.answerFormat.startsWith("angle_deg") &&
              currentProblem.answerFormat !== "angle_deg_min"
            ) {
              displayCorrect += "°";
            }
          } else if (currentProblem.answerFormat === "angle_deg_min") {
            displayCorrect = currentProblem.correctAnswer; // Should already be formatted
          }

          feedbackDiv.innerHTML = `<strong>Incorrecto.</strong> La respuesta correcta es ${displayCorrect}.<hr><p><strong>Explicación:</strong></p>${currentProblem.explanation}`;
          feedbackDiv.className = "incorrect";
          renderMath(feedbackDiv); // Render math in the explanation
        }
      });

      // New Problem
      newProblemButton.addEventListener("click", () => {
        generateProblem();
      });

      // Previous Problem
      prevProblemButton.addEventListener("click", () => {
        if (previousProblem) {
          // Store current state before overwriting
          const tempProblem = currentProblem ? { ...currentProblem } : null;
          const tempAnswer = answerInput.value;
          const tempProcedure = procedureArea.value;

          // Restore previous state
          currentProblem = previousProblem; // Restore the actual previous problem object
          answerInput.value = previousUserAnswer;
          procedureArea.value = previousProcedure; // Restore procedure

          // Set the 'previousProblem' state back to what *was* current (just before clicking prev)
          // Only store if tempProblem was a valid problem state
          if (
            tempProblem &&
            tempProblem.questionText &&
            tempProblem.questionText !== "Selecciona un tema para empezar."
          ) {
            previousProblem = tempProblem;
            previousUserAnswer = tempAnswer;
            previousProcedure = tempProcedure;
          } else {
            // If the 'current' state we are leaving wasn't a real problem,
            // effectively clear the previous state again.
            previousProblem = null;
            previousUserAnswer = "";
            previousProcedure = "";
          }

          problemDisplay.innerHTML = currentProblem.questionText;
          renderMath(problemDisplay);
          feedbackDiv.innerHTML = ""; // Clear feedback
          feedbackDiv.className = "";

          setButtonsState(true); // Update button states (Prev might become disabled now if previousProblem is null)
        }
      });

      // --- Initial Setup ---
      // Add event listener to wait for KaTeX scripts to potentially load
      document.addEventListener("DOMContentLoaded", () => {
        setButtonsState(false); // Disable check/new/prev initially
        prevProblemButton.disabled = true; // Explicitly disable prev at start
        problemDisplay.textContent = "Selecciona un tema para empezar.";

        // Small delay to give CDN scripts a moment to load before potentially rendering initial state (if any)
        // setTimeout(() => {
        //     // You could potentially call renderMath(document.body) here if needed
        // }, 100);
      });
    </script>
  </body>
</html>
